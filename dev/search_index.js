var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Nucleus-Distributions","page":"API","title":"Nucleus Distributions","text":"","category":"section"},{"location":"api/#Participants-and-Sampling","page":"API","title":"Participants and Sampling","text":"","category":"section"},{"location":"api/#Event-Observables","page":"API","title":"Event Observables","text":"","category":"section"},{"location":"api/#Background-and-Correlators","page":"API","title":"Background and Correlators","text":"","category":"section"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/#MonteCarloGlauber.NucleiWoodSaxon3D","page":"API","title":"MonteCarloGlauber.NucleiWoodSaxon3D","text":"NucleiWoodSaxon3D{T,R,C,W,D1,D2,D3,D4,B,samp}\n\nRepresentation of a deformed 3D Woods–Saxon nucleus suitable for sampling.\n\nFields\n\nN_nucleon::Int64 — number of nucleons per sample.\nα — surface diffuseness parameter.\nR — nuclear radius parameter.\nρ₀ — central density normalization.\nw — quadratic modulation coefficient.\nbeta2, beta3, beta4 — deformation parameters (spherical-harmonic multipoles).\ngamma — triaxiality angle used with beta2.\nburning_time — number of burn-in transitions for the internal MCMC sampler.\nsampler — internal Metropolis_Hastings sampler that proposes 3D locations according to the deformed density.\nd_min — minimum inter-nucleon separation (when zero no separation enforcement is performed).\n\nBehavior\n\nSamples are drawn in 3D using the internal sampler and then a random 3×3 rotation is applied; the object returns transverse (x,y) coordinates (an (N_nucleon, 2) array) by projecting the rotated 3D positions.\n\nNotes\n\nThe type implements Sampleable{ArrayLikeVariate{2}, Continuous} and is intended for use with rand/Distributions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.IntegratedWoodSaxon","page":"API","title":"MonteCarloGlauber.IntegratedWoodSaxon","text":"IntegratedWoodSaxon{T,R,C,W,samp}\n\nRepresentation of a two-dimensional, integrated Wood–Saxon nucleon distribution suitable for sampling.\n\nFields\n\nN_nucleon::Int64 — number of nucleons returned per draw (samples have shape (N_nucleon, 2)).\nα::T — surface diffuseness (or deformation parameter feeding into the radial dependence).\nR::R — characteristic nuclear radius used to set the spatial scale.\nρ₀::C — central density normalization.\nw::W — optional quadratic deformation coefficient that modulates the radial profile.\nretol::Float64 — relative tolerance passed to the quadrature used when building the projected density.\nburning_time::Int64 — number of burn-in (warmup) iterations used by the internal Metropolis_Hastings sampler.\nsampler::samp — sampler object (typically Metropolis_Hastings) that draws correlated 2D positions from the projected density.\nrotated::Bool — when true, each sampled configuration is post-multiplied by a random RotMatrix{2} so the orientation is randomized.\n\nNotes\n\nImplements Sampleable{ArrayLikeVariate{2}, Continuous} and is intended to be used with rand/Distributions to obtain (N_nucleon, 2) coordinate samples.\nThe sampler targets the integrated (projected) density obtained by integrating the Woods–Saxon density along the longitudinal axis.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.IntegratedWoodSaxonInterp","page":"API","title":"MonteCarloGlauber.IntegratedWoodSaxonInterp","text":"IntegratedWoodSaxonInterp{T,R,C,W,B,Inte,samp}\n\nA sampleable object representing a two-dimensional integrated Wood–Saxon nucleon density.\n\nFields\n\nN_nucleon::Int64 — number of nucleons to draw per sample (returned sample has size (N_nucleon, 2)).\nα::T — diffuseness parameter (controls surface thickness).\nR::R — nuclear radius scale.\nρ₀::C — central density normalization.\nw::W — surface diffuseness parameter.\nburning_time::B — number of burn-in (warmup) steps for the internal Metropolis–Hastings sampler.\nretol::Float64 — relative tolerance passed to the numerical quadrature used when building the interpolant.\nnpoint::Int — number of grid points per axis used to compute the interpolant.\ninterpolation::Inte — scaled B-spline interpolant (2D) approximating the integrated density used as a target for sampling.\nsampler::samp — sampler object (typically Metropolis_Hastings) used to produce correlated samples.\nrotated::Bool — if true, each sampled configuration is rotated by a random 2×2 rotation matrix before being returned.\n\nNotes\n\nImplements Sampleable{ArrayLikeVariate{2}, Continuous} and provides size, dimension, and sampling via rand / Distributions._rand!.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.TabulatedEvent","page":"API","title":"MonteCarloGlauber.TabulatedEvent","text":"TabulatedEvent(filename)\n\nLoad a set of precomputed light-ion configurations from an HDF5 file and construct a Sampleable over transverse nucleon positions.\n\nFile format\n\nThe HDF5 file should contain a dataset named configs with shape (3, N_nucleon, N_configs), where the first axis indexes Cartesian coords (x,y,z), the second axis indexes nucleons, and the third axis indexes different configuration realizations.\n\nBehavior\n\nEach sample selects a config index uniformly at random, applies a random 3D rotation (if rotated==true), projects to the transverse plane by taking the first two coordinates, and returns an (N_nucleon, 2) matrix of positions.\n\nExample\n\njulia> s = TabulatedEvent(\"configs.h5\")\njulia> pos = rand(s)  # pos has shape (N_nucleon, 2)\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.Uranium","page":"API","title":"MonteCarloGlauber.Uranium","text":"Uranium()\n\nReturn a Woods-Saxon uranium nucleus (A = 238) with default deformation parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Lead","page":"API","title":"MonteCarloGlauber.Lead","text":"Lead()\n\nReturn a Woods-Saxon lead nucleus (A = 208) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Gold","page":"API","title":"MonteCarloGlauber.Gold","text":"Gold()\n\nReturn a Woods-Saxon gold nucleus (A = 197) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Copper","page":"API","title":"MonteCarloGlauber.Copper","text":"Copper()\n\nReturn a Woods-Saxon copper nucleus (A = 63) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Xenon","page":"API","title":"MonteCarloGlauber.Xenon","text":"Xenon()\n\nReturn a Woods-Saxon xenon nucleus (A = 129) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Oxygen","page":"API","title":"MonteCarloGlauber.Oxygen","text":"Oxygen()\n\nReturn a tabulated light-ion configuration for oxygen from the built-in artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Neon","page":"API","title":"MonteCarloGlauber.Neon","text":"Neon()\n\nReturn a tabulated light-ion configuration for neon from the built-in artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Participants","page":"API","title":"MonteCarloGlauber.Participants","text":"Participants{A,B,C,D,E,F,G,H,L}\n\nContainer describing a two‑nucleus collision setup and providing a Sampleable that generates Participant events.\n\nFields\n\nnucl1, nucl2 — nucleus samplers for the two colliding nuclei.\nsub_nucleon_width — Gaussian width (σ) used for the transverse matter distribution of sub‑nucleonic degrees of freedom.\ninpact_parameter_magitude — distribution for the impact parameter magnitude (radial distribution).\ninpact_parameter_angle — distribution for the impact parameter angle (azimuthal orientation).\nsigma_gg — per‑gluon (partonic) cross section used in computing binary collision probabilities.\nshape_parameter — Gamma distribution shape parameter used to sample per‑participant fluctuation weights.\ntotal_cross_section — inelastic nucleon‑nucleon cross section at the chosen energy (σ_NN).\np — exponent used when combining thickness functions (p‑mean: p = 0 implies geometric mean).\naccumulation_preparation — precomputed data used to accelerate center‑of‑mass and accumulation calculations.\n\nNotes\n\nImplements Sampleable{Univariate, Participant}, and rand(rng, participants) returns a sampled Participant event describing one collision configuration.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.Participant","page":"API","title":"MonteCarloGlauber.Participant","text":"Participant\n\nContainer for a single sampled collision event.\n\nParticipant stores participant positions for both nuclei, per-participant weights, binary-collision count, sampling parameters, and derived quantities such as the impact parameter and total multiplicity. The object is callable: evt(x, y) returns the fluctuating thickness at (x, y).\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.threaded","page":"API","title":"MonteCarloGlauber.threaded","text":"threaded(elem)\n\nReturn a Threaded wrapper around elem to enable multithreaded sampling with rand.\n\nArguments\n\nelem — a Sampleable object (for example, an IntegratedWoodSaxon) which will be replicated into thread-local buffers.\n\nBehavior\n\nCreates 2 * nthreads() thread-local copies by default via Threaded(elem, 2 * nthreads()).\nEach copy has an independent internal sampler state so concurrent calls to rand are thread-safe and do not share sampler state.\nWhen sampling with rand(rng, threaded(elem), n) the total workload is split among the internal buffers and executed in parallel, improving throughput on multi-core machines.\n\nExamples\n\njulia> s = IntegratedWoodSaxon(100, 0.5, 5.4, 0.16, 0.0)   # create a sampler for 100 nucleons\njulia> ts = threaded(s)                                   # wrap for multithreaded sampling\njulia> samples = rand(ts, 4)                              # produce 4 samples; returned matrix concatenates them\n\nNotes\n\nThis is a lightweight convenience function; it does not change the semantics or shape of the samples returned by elem.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Threaded","page":"API","title":"MonteCarloGlauber.Threaded","text":"Threaded(elem[, nbuffers])\n\nWrapper that stores thread-local copies of a sampleable object to enable multithreaded sampling with rand.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.impactParameter","page":"API","title":"MonteCarloGlauber.impactParameter","text":"impactParameter(evt::Participant)\n\nReturn the impact parameter b for a sampled event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.multiplicity","page":"API","title":"MonteCarloGlauber.multiplicity","text":"multiplicity(evt::Participant)\n\nReturn the total multiplicity (entropy-like weight) for a sampled event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.n_coll","page":"API","title":"MonteCarloGlauber.n_coll","text":"n_coll(evt::Participant)\n\nReturn the number of binary nucleon-nucleon collisions in the event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.n_part","page":"API","title":"MonteCarloGlauber.n_part","text":"n_part(evt::Participant)\n\nReturn the number of participating nucleons in the event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.center_of_mass","page":"API","title":"MonteCarloGlauber.center_of_mass","text":"center_of_mass(con; Nr=64, Nth=64)\n\nCompute center of mass using Gauss–Legendre quadrature in r and trapezoidal rule in θ. This converges faster than the uniform grid for smooth profiles.\n\nArguments\n\ncon::Participant: The participant configuration.\nNr: Number of Gauss–Legendre nodes (radial).\nNth: Number of angular divisions (trapezoid).\n\nReturns\n\n(mult, x_cm, y_cm): Multiplicity and first moments.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.center_of_mass!","page":"API","title":"MonteCarloGlauber.center_of_mass!","text":"center_of_mass!(con, cache)\n\nNon-allocating variant using pre-computed cache from prepare_accumulation(con, Nr, Nth).\n\nArguments\n\ncon::Participant: configuration to integrate.\ncache: NamedTuple with (rvals, rweights, sinθ, cosθ).\n\nReturns\n\n(mult, x_cm, y_cm): Multiplicity and first moments.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.prepare_accumulation","page":"API","title":"MonteCarloGlauber.prepare_accumulation","text":"prepare_accumulation(con, Nr=64, Nth=64)\n\nPre-compute radial nodes/weights mapped to [0, Rmax] and sin/cos arrays for θ. Returns a NamedTuple (rvals, rweights, sinθ, cosθ) ready for use in _gl! functions.\n\nArguments\n\ncon::Participant: participant to get R1, R2 from.\nNr: Number of Gauss–Legendre nodes (radial).\nNth: Number of angular divisions.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.epsilon_n_psi_n","page":"API","title":"MonteCarloGlauber.epsilon_n_psi_n","text":"epsilon_n_psi_n(con, n; Nr=64, Nth=64)\n\nConvenience wrapper that prepares a quadrature cache and calls epsilon_n_psi_n!(...).\n\nArguments\n\ncon::Participant: Callable density/weight function con(x, y).\nn::Integer: Harmonic order.\nNr, Nth: Optional quadrature resolution for radial and angular integrations (defaults: 64).\n\nReturns\n\n(ε_n, ψ_n) from epsilon_n_psi_n!.\n\nExample\n\nε2, ψ2 = epsilon_n_psi_n(participant, 2, Nr=128, Nth=128)\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.epsilon_n_psi_n!","page":"API","title":"MonteCarloGlauber.epsilon_n_psi_n!","text":"epsilon_n_psi_n!(con, cache, n)\n\nCompute the nth-order eccentricity εn and event-plane angle ψn using a pre-computed quadrature cache.\n\nArguments\n\ncon::Participant: Callable density/weight function con(x, y) that returns the local density at coordinates (x, y).\ncache: NamedTuple produced by prepare_accumulation, containing r_vals, r_weights, sinθ, cosθ, θ_weight, and θ_vals.\nn::Integer: Harmonic order (n ≥ 0).\n\nReturns\n\n(ε_n, ψ_n): where\nε_n = sqrt(Q_x^2 + Q_y^2) / Q_0, with\nQ_0 = Σ m(r, θ) * r^n,\nQ_x = Σ cos(nθ) * m(r, θ) * r^n,\nQ_y = Σ sin(nθ) * m(r, θ) * r^n,\nand m(r, θ) = con(x, y) * r_weight * θ_weight.\nψ_n = atan(Q_y, Q_x) (in radians).\n\nNotes\n\nThis is the non-allocating variant: it uses the supplied cache and avoids recomputing quadrature nodes/weights.\nThe implementation uses sincos(n * θ) for angular factors; alternatively cos_sin_n(c, s, n) may be used when cos(θ) and sin(θ) are already available.\n\nExample\n\ncache = prepare_accumulation(participant, Nr=64, Nth=128)\nε, ψ = epsilon_n_psi_n!(participant, cache, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.generate_bg_twpt_fct","page":"API","title":"MonteCarloGlauber.generate_bg_twpt_fct","text":"generate_bg_twpt_fct(f, delta_factor, norm, Projectile1, Projectile2, w, k, p, sqrtS, bins, mList; ...)\n\nHigh-level routine that generates a background profile and converts two-point correlators to the desired observable space.\n\nArguments\n\nf: Function applied to the normalized background values (e.g., equation-of-state transform).\ndelta_factor: Function to convert entropy-space correlators to the target observable.\nnorm: Normalization factor applied to profiles before averaging.\nProjectile1, Projectile2, w, k, p, sqrtS: Parameters used to construct Participants.\nbins, mList: Centrality bins and list of harmonics.\nKeyword arguments control event sampling and resolution: minBiasEvents, r_grid, NumPhiPoints, Threaded, Nfields.\n\nReturns\n\n(bg, correlator): Background array and correlator tensor in the target observable space (after applying delta_factor).\n\nNotes\n\nThis wrapper samples events (threaded if requested), computes background (generate_bg) and entropy-space correlators (generate_tw_pt_fct_entropy) and then applies delta_factor pointwise to obtain correlator.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.InverseFunction","page":"API","title":"MonteCarloGlauber.InverseFunction","text":"InverseFunction{N, F}(fun)\n\nWrapper for creating callable inverse functions. The returned object is callable: invf(x; u0=...) and numerically solves fun(u) = x for u.\n\nDescription\n\nInverseFunction(f) constructs a lightweight object holding f which can be used to compute the inverse of f numerically.\nThe callable form invf(x; u0 = 0.1*one(x)) uses a Newton–Raphson solver (via NonlinearProblem and SimpleNewtonRaphson) to find u such that f(u) == x.\n\nArguments\n\nfun::F: A function of one variable mapping from domain to codomain.\nx: Target value for which the inverse is sought.\nu0: Optional initial guess for the root-finder (default 0.1 * one(x)).\n\nReturns\n\nu: Numeric solution such that fun(u) ≈ x (returned from the solver's .u).\n\nNotes\n\nThe implementation uses a NonlinearProblem with a residual fun(u) - x and relies on SimpleNewtonRaphson for solving; users should ensure fun is reasonably well-behaved and provide suitable u0 for robust convergence.\n\nExample\n\ninvf = InverseFunction(x -> 2x)\ninvf(1.0) # -> 0.5\n\n\n\n\n\n","category":"type"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"import Pkg\nPkg.add(url = \"https://github.com/AndreasKirchner/MonteCarloGlauber.jl\")\n\nThen load the package:\n\nusing MonteCarloGlauber","category":"section"},{"location":"quickstart/#Sample-Events","page":"Quickstart","title":"Sample Events","text":"n1 = Lead()\nn2 = Lead()\n\nw = 0.5\ns_NN = 2760\nk = 1\np = 0.0\n\nparticipants = Participants(n1, n2, w, s_NN, k, p)\nevents = rand(participants, 10_000)","category":"section"},{"location":"quickstart/#Multithreaded-Sampling","page":"Quickstart","title":"Multithreaded Sampling","text":"To use all threads when sampling many events:\n\nevents = rand(threaded(participants), 100_000)","category":"section"},{"location":"quickstart/#Basic-Observables","page":"Quickstart","title":"Basic Observables","text":"mult = multiplicity.(events)\ncoll = getfield.(events, :n_coll)\nb = impactParameter.(events)\n\n(Image: Histograms)","category":"section"},{"location":"quickstart/#Evaluate-an-Event-on-a-Grid","page":"Quickstart","title":"Evaluate an Event on a Grid","text":"Participant objects are callable and return the fluctuating thickness at (x, y):\n\nevt = events[1]\nprofile = [evt(x, y) for x in -10:0.5:10, y in -10:0.5:10]\n\n(Image: Example plot)","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Centrality-Selection","page":"Examples","title":"Centrality Selection","text":"centralities_selection_events partitions events by multiplicity (most central first). The bins vector defines the upper edges of the centrality classes in percent.\n\nn1 = Oxygen()\nn2 = Oxygen()\n\nparticipants = Participants(n1, n2, 0.5, 2760, 1.0, 0.0)\nevents = rand(threaded(participants), 200_000)\n\nbins = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nbatches = centralities_selection_events(events, bins)\n\ncentral_0_10 = batches[1]\nperipheral_50_60 = batches[6]","category":"section"},{"location":"examples/#Eccentrities","page":"Examples","title":"Eccentrities","text":"epsilon_n_psi_n computes the n-th eccentricity of a given event. The following script can be used to compute e.g. the average epsilon_2 in the specified centrality classes.\n\nm = 2\nfunction avg_eccentricity(batch, n)\n    ecc = epsilon_n_psi_n.(batch, n)\n    return mean(getindex.(ecc, 1)), mean(getindex.(ecc, 2))\nend\necc2 = [avg_eccentricity(batches[i], m) for i in eachindex(batches)]\n\necc2_magnitude = getindex.(ecc2, 1)\necc2_angle = getindex.(ecc2, 2)\n\n(Image: Example plot)","category":"section"},{"location":"examples/#Background-and-Two-Point-Correlator","page":"Examples","title":"Background and Two-Point Correlator","text":"This is a high-level workflow that builds the background profile and correlators. It can be expensive for large minBiasEvents.\n\nfmGeV = 5.0\nentropy(T) = 47.5 * 4 * T^3 * pi^2 / 90 * fmGeV^3\nentropyToTemp = InverseFunction(entropy)\ndSdT(T) = 1 / (3 * 47.5 * 4 * T^2 * pi^2 / 90 * fmGeV^2)\n\nNorm = 100\nm_list = [2,3]\n\nbg, twpt = generate_bg_twpt_fct(entropyToTemp,dSdT,\n    Norm,\n    n1,n2,w ,k,p,s_NN, \n    bins, m_list; \n    minBiasEvents = 1000, r_grid = 0:1.:5, NumPhiPoints = 20, Threaded = true, Nfields = 10)\n\nThe function return an error if not enough minBiasEvents are provided for the selected amount of bins.","category":"section"},{"location":"examples/#Background-and-Two-Point-Correlator-with-File-I/O","page":"Examples","title":"Background and Two-Point Correlator with File I/O","text":"You can also generate the background profiles and two-point correlators while automatically saving them to disk using generate_bg_twpt_fct_save. This function processes each centrality bin separately, allowing it to read previously computed results and avoid recomputation.\n\nbg, twpt = generate_bg_twpt_fct_save(entropyToTemp, dSdT,\n    Norm,\n    n1, n2, w ,k,p,s_NN,\n    bins, m_list;\n    minBiasEvents = 1000,\n    r_grid = 0:1.:5,\n    NumPhiPoints = 20,\n    Threaded = true,\n    Nfields = 10,\n    path = \"./results/\",\n    override_files = false)\n\nThe function will:\n\nCreate a Participants object and sample events for each centrality bin.\nWrite background profiles and correlators to disk using the naming convention from construct_trento_names.\nIf files already exist and override_files=false, it will read from disk instead of recomputing.\nReturn the full bg array and correlator tensor twpt across all bins.\n\nThis approach is useful for expensive calculations or workflows where you need persistent storage of intermediate results.","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Model-Parameters","page":"Background","title":"Model Parameters","text":"The Glauber model here exposes the following common parameters:\n\nw: Sub-nucleon width (fm). Controls the smearing of participant thickness.\nk: Fluctuation (shape) parameter for Gamma-distributed participant weights.\np: Reduced thickness parameter in the generalized mean.\ns_NN: Center-of-mass energy in GeV; used to compute the inelastic cross section.\nNorm : Normalization of entropy density profile","category":"section"},{"location":"background/#Impact-Parameter","page":"Background","title":"Impact Parameter","text":"When you call Participants(n1, n2, w, s_NN, k, p) without an explicit impact parameter range, the code generates minimum-bias events with an internal default range. To restrict the impact parameter distribution, pass a tuple (bmin, bmax) as the last positional argument:\n\nparticipants = Participants(n1, n2, w, s_NN, k, p, (1.0, 2.0))","category":"section"},{"location":"background/#Nucleus-Choices","page":"Background","title":"Nucleus Choices","text":"Use one of the built-in nucleus helpers:\n\nLead(), Gold(), Uranium(), Copper(), Xenon() for Woods-Saxon nuclei.\nOxygen() and Neon() for tabulated light-ion configurations.","category":"section"},{"location":"background/#Event-Profiles","page":"Background","title":"Event Profiles","text":"Participant objects are callable: evt(x, y) returns the fluctuating thickness at coordinates (x, y). This enables direct integration for eccentricities or sampling on grids for visualization.","category":"section"},{"location":"#MonteCarloGlauber.jl","page":"Home","title":"MonteCarloGlauber.jl","text":"MonteCarloGlauber.jl generates initial conditions for heavy-ion collisions using a Monte Carlo Glauber model with sub-nucleonic fluctuations. It provides 3D Woods-Saxon sampling, participant and binary-collision counting, and utilities for centrality selection and two-point correlators.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Deformed 3D Woods-Saxon nuclei (NucleiWoodSaxon3D).\nIntegrated Woods-Saxon sampling with interpolation (IntegratedWoodSaxon, IntegratedWoodSaxonInterp).\nEvent-by-event participants and multiplicities (Participants, Participant).\nLight-ion configurations via artifacts (Oxygen, Neon).\nBackground and two-point correlator helpers (generate_bg_two_pt_fct, generate_bg_twpt_fct).","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"using MonteCarloGlauber\n\nn1 = Lead()\nn2 = Lead()\n\nw = 0.5\ns_NN = 2760\nk = 1\np = 0.0\n\nparticipants = Participants(n1, n2, w, s_NN, k, p)\nevents = rand(participants, 1000)\n\nmult = multiplicity.(events)\nb = impactParameter.(events)\n\nSee the Quickstart and Examples pages for more complete workflows.","category":"section"}]
}
