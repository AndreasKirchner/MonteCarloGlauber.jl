var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Nucleus-Distributions","page":"API","title":"Nucleus Distributions","text":"","category":"section"},{"location":"api/#Participants-and-Sampling","page":"API","title":"Participants and Sampling","text":"","category":"section"},{"location":"api/#Event-Observables","page":"API","title":"Event Observables","text":"","category":"section"},{"location":"api/#Background-and-Correlators","page":"API","title":"Background and Correlators","text":"","category":"section"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/#MonteCarloGlauber.NucleiWoodSaxon3D","page":"API","title":"MonteCarloGlauber.NucleiWoodSaxon3D","text":"NucleiWoodSaxon3D(N_nucleon,α,R,ρ₀,w,beta2,beta3,beta4,gamma)\n\nCreate a 3D distribution of nucleons in a nucleus with a Wood-Saxon density profile. The density profile is deformed by the parameters beta2, beta3, beta4, and gamma. The number of nucleons is N_nucleon, the radius is R, the diffuseness is α, the central density is ρ₀, and the skin depth is w.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.IntegratedWoodSaxon","page":"API","title":"MonteCarloGlauber.IntegratedWoodSaxon","text":"IntegratedWoodSaxon(N_nucleon::Int,α,R,ρ₀,w,rotated=true,retol=1e-3\n,rng=Random.default_rng()\n,burning_time=1000)\n\nCreate a sampleable object that represents a Wood Saxon distribution with a given number of nucleons. The distribution is deformed by the parameters α, R, ρ₀, and w. The number of nucleons is N_nucleon.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.IntegratedWoodSaxonInterp","page":"API","title":"MonteCarloGlauber.IntegratedWoodSaxonInterp","text":"IntegratedWoodSaxonInterp(N_nucleon,α,R,ρ₀,w,rng=Random.default_rng(),rotated=true)\n\nCreate a sampleable object that represents a Wood Saxon distribution with a given number of nucleons. The distribution is deformed by the parameters α, R, ρ₀, and w. The number of nucleons is N_nucleon.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.TabulatedEvent","page":"API","title":"MonteCarloGlauber.TabulatedEvent","text":"TabulatedEvent(path)\n\nLoad a tabulated light-ion configuration from an HDF5 file and return a sampleable distribution over nucleon positions.\n\nThe file is expected to contain a configs dataset with shape (3, N_nucleon, N_configs); sampling draws a random configuration and applies a random 3D rotation.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.Uranium","page":"API","title":"MonteCarloGlauber.Uranium","text":"Uranium()\n\nReturn a Woods-Saxon uranium nucleus (A = 238) with default deformation parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Lead","page":"API","title":"MonteCarloGlauber.Lead","text":"Lead()\n\nReturn a Woods-Saxon lead nucleus (A = 208) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Gold","page":"API","title":"MonteCarloGlauber.Gold","text":"Gold()\n\nReturn a Woods-Saxon gold nucleus (A = 197) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Copper","page":"API","title":"MonteCarloGlauber.Copper","text":"Copper()\n\nReturn a Woods-Saxon copper nucleus (A = 63) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Xenon","page":"API","title":"MonteCarloGlauber.Xenon","text":"Xenon()\n\nReturn a Woods-Saxon xenon nucleus (A = 129) with default parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Oxigen","page":"API","title":"MonteCarloGlauber.Oxigen","text":"Oxigen()\n\nReturn a tabulated light-ion configuration for oxygen from the built-in artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Neon","page":"API","title":"MonteCarloGlauber.Neon","text":"Neon()\n\nReturn a tabulated light-ion configuration for neon from the built-in artifact.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Participants","page":"API","title":"MonteCarloGlauber.Participants","text":"Participants(n1,n2,w,s_NN,k,p[,b])\n\nConstructor for the Participants distribution. It takes the following arguments:     n1: Nucleus 1     n2: Nucleus 2     w: Subnucleon width     s_NN: Energy in GeV     k: Shape parameter     p: Norm parameter     b: Impact parameter distribution (optional) \n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.Participant","page":"API","title":"MonteCarloGlauber.Participant","text":"Participant\n\nContainer for a single sampled collision event.\n\nParticipant stores participant positions for both nuclei, per-participant weights, binary-collision count, sampling parameters, and derived quantities such as the impact parameter and total multiplicity. The object is callable: evt(x, y) returns the fluctuating thickness at (x, y).\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.threaded","page":"API","title":"MonteCarloGlauber.threaded","text":"threaded(elm)\n\nCreate a sampleable object that will mutithread the call of rand.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.Threaded","page":"API","title":"MonteCarloGlauber.Threaded","text":"Threaded(elem[, nbuffers])\n\nWrapper that stores thread-local copies of a sampleable object to enable multithreaded sampling with rand.\n\n\n\n\n\n","category":"type"},{"location":"api/#MonteCarloGlauber.impactParameter","page":"API","title":"MonteCarloGlauber.impactParameter","text":"impactParameter(evt::Participant)\n\nReturn the impact parameter b for a sampled event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.multiplicity","page":"API","title":"MonteCarloGlauber.multiplicity","text":"multiplicity(evt::Participant)\n\nReturn the total multiplicity (entropy-like weight) for a sampled event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.n_coll","page":"API","title":"MonteCarloGlauber.n_coll","text":"n_coll(evt::Participant)\n\nReturn the number of binary nucleon-nucleon collisions in the event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.n_part","page":"API","title":"MonteCarloGlauber.n_part","text":"n_part(evt::Participant)\n\nReturn the number of participating nucleons in the event.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.center_of_mass","page":"API","title":"MonteCarloGlauber.center_of_mass","text":"center_of_mass(con; Nr=64, Nth=64)\n\nCompute center of mass using Gauss–Legendre quadrature in r and trapezoidal rule in θ. This converges faster than the uniform grid for smooth profiles.\n\nArguments\n\ncon::Participant: The participant configuration.\nNr: Number of Gauss–Legendre nodes (radial).\nNth: Number of angular divisions (trapezoid).\n\nReturns\n\n(mult, x_cm, y_cm): Multiplicity and first moments.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.center_of_mass!","page":"API","title":"MonteCarloGlauber.center_of_mass!","text":"center_of_mass!(con, cache)\n\nNon-allocating variant using pre-computed cache from prepare_accumulation(con, Nr, Nth).\n\nArguments\n\ncon::Participant: configuration to integrate.\ncache: NamedTuple with (rvals, rweights, sinθ, cosθ).\n\nReturns\n\n(mult, x_cm, y_cm): Multiplicity and first moments.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.prepare_accumulation","page":"API","title":"MonteCarloGlauber.prepare_accumulation","text":"prepare_accumulation(con, Nr=64, Nth=64)\n\nPre-compute radial nodes/weights mapped to [0, Rmax] and sin/cos arrays for θ. Returns a NamedTuple (rvals, rweights, sinθ, cosθ) ready for use in _gl! functions.\n\nArguments\n\ncon::Participant: participant to get R1, R2 from.\nNr: Number of Gauss–Legendre nodes (radial).\nNth: Number of angular divisions.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.epsilon_n_psi_n","page":"API","title":"MonteCarloGlauber.epsilon_n_psi_n","text":"epsilon_n_psi_n(con, n; Nr=64, Nth=64)\n\nConvenience wrapper that prepares a quadrature cache and calls epsilon_n_psi_n!(...).\n\nArguments\n\ncon::Participant: Callable density/weight function con(x, y).\nn::Integer: Harmonic order.\nNr, Nth: Optional quadrature resolution for radial and angular integrations (defaults: 64).\n\nReturns\n\n(ε_n, ψ_n) from epsilon_n_psi_n!.\n\nExample\n\nε2, ψ2 = epsilon_n_psi_n(participant, 2, Nr=128, Nth=128)\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.epsilon_n_psi_n!","page":"API","title":"MonteCarloGlauber.epsilon_n_psi_n!","text":"epsilon_n_psi_n!(con, cache, n)\n\nCompute the nth-order eccentricity εn and event-plane angle ψn using a pre-computed quadrature cache.\n\nArguments\n\ncon::Participant: Callable density/weight function con(x, y) that returns the local density at coordinates (x, y).\ncache: NamedTuple produced by prepare_accumulation, containing r_vals, r_weights, sinθ, cosθ, θ_weight, and θ_vals.\nn::Integer: Harmonic order (n ≥ 0).\n\nReturns\n\n(ε_n, ψ_n): where\nε_n = sqrt(Q_x^2 + Q_y^2) / Q_0, with\nQ_0 = Σ m(r, θ) * r^n,\nQ_x = Σ cos(nθ) * m(r, θ) * r^n,\nQ_y = Σ sin(nθ) * m(r, θ) * r^n,\nand m(r, θ) = con(x, y) * r_weight * θ_weight.\nψ_n = atan(Q_y, Q_x) (in radians).\n\nNotes\n\nThis is the non-allocating variant: it uses the supplied cache and avoids recomputing quadrature nodes/weights.\nThe implementation uses sincos(n * θ) for angular factors; alternatively cos_sin_n(c, s, n) may be used when cos(θ) and sin(θ) are already available.\n\nExample\n\ncache = prepare_accumulation(participant, Nr=64, Nth=128)\nε, ψ = epsilon_n_psi_n!(participant, cache, 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.generate_bg_twpt_fct","page":"API","title":"MonteCarloGlauber.generate_bg_twpt_fct","text":"generate_bg_twpt_fct(f, delta_factor, norm, Projectile1, Projectile2, w, k, p, sqrtS, bins, mList; ...)\n\nHigh-level routine that generates a background profile and converts two-point correlators to the desired observable space.\n\nArguments\n\nf: Function applied to the normalized background values (e.g., equation-of-state transform).\ndelta_factor: Function to convert entropy-space correlators to the target observable.\nnorm: Normalization factor applied to profiles before averaging.\nProjectile1, Projectile2, w, k, p, sqrtS: Parameters used to construct Participants.\nbins, mList: Centrality bins and list of harmonics.\nKeyword arguments control event sampling and resolution: minBiasEvents, r_grid, NumPhiPoints, Threaded, Nfields.\n\nReturns\n\n(bg, correlator): Background array and correlator tensor in the target observable space (after applying delta_factor).\n\nNotes\n\nThis wrapper samples events (threaded if requested), computes background (generate_bg) and entropy-space correlators (generate_tw_pt_fct_entropy) and then applies delta_factor pointwise to obtain correlator.\n\n\n\n\n\n","category":"function"},{"location":"api/#MonteCarloGlauber.InverseFunction","page":"API","title":"MonteCarloGlauber.InverseFunction","text":"InverseFunction{N, F}(fun)\n\nWrapper for creating callable inverse functions. The returned object is callable: invf(x; u0=...) and numerically solves fun(u) = x for u.\n\nDescription\n\nInverseFunction(f) constructs a lightweight object holding f which can be used to compute the inverse of f numerically.\nThe callable form invf(x; u0 = 0.1*one(x)) uses a Newton–Raphson solver (via NonlinearProblem and SimpleNewtonRaphson) to find u such that f(u) == x.\n\nArguments\n\nfun::F: A function of one variable mapping from domain to codomain.\nx: Target value for which the inverse is sought.\nu0: Optional initial guess for the root-finder (default 0.1 * one(x)).\n\nReturns\n\nu: Numeric solution such that fun(u) ≈ x (returned from the solver's .u).\n\nNotes\n\nThe implementation uses a NonlinearProblem with a residual fun(u) - x and relies on SimpleNewtonRaphson for solving; users should ensure fun is reasonably well-behaved and provide suitable u0 for robust convergence.\n\nExample\n\ninvf = InverseFunction(x -> 2x)\ninvf(1.0) # -> 0.5\n\n\n\n\n\n","category":"type"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"quickstart/#Installation","page":"Quickstart","title":"Installation","text":"import Pkg\nPkg.add(url = \"https://github.com/AndreasKirchner/MonteCarloGlauber.jl\")\n\nThen load the package:\n\nusing MonteCarloGlauber","category":"section"},{"location":"quickstart/#Sample-Events","page":"Quickstart","title":"Sample Events","text":"n1 = Lead()\nn2 = Lead()\n\nw = 0.5\ns_NN = 2760\nk = 1\np = 0.0\n\nparticipants = Participants(n1, n2, w, s_NN, k, p)\nevents = rand(participants, 10_000)","category":"section"},{"location":"quickstart/#Multithreaded-Sampling","page":"Quickstart","title":"Multithreaded Sampling","text":"To use all threads when sampling many events:\n\nevents = rand(threaded(participants), 100_000)","category":"section"},{"location":"quickstart/#Basic-Observables","page":"Quickstart","title":"Basic Observables","text":"mult = multiplicity.(events)\ncoll = getfield.(events, :n_coll)\n\nb = impactParameter.(events)","category":"section"},{"location":"quickstart/#Evaluate-an-Event-on-a-Grid","page":"Quickstart","title":"Evaluate an Event on a Grid","text":"Participant objects are callable and return the fluctuating thickness at (x, y):\n\nevt = events[1]\nprofile = [evt(x, y) for x in -10:0.5:10, y in -10:0.5:10]","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Centrality-Selection","page":"Examples","title":"Centrality Selection","text":"centralities_selection_events partitions events by multiplicity (most central first). The bins vector defines the upper edges of the centrality classes in percent.\n\nn1 = Oxigen()\nn2 = Oxigen()\n\nparticipants = Participants(n1, n2, 0.5, 2760, 1.0, 0.0)\nevents = rand(threaded(participants), 200_000)\n\nbins = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nbatches = MonteCarloGlauber.centralities_selection_events(events, bins)\n\ncentral_0_10 = batches[1]\nperipheral_50_60 = batches[6]","category":"section"},{"location":"examples/#Background-and-Two-Point-Correlator","page":"Examples","title":"Background and Two-Point Correlator","text":"This is a high-level workflow that builds the background profile and correlators. It can be expensive for large minBiasEvents.\n\nfmGeV = 5.0\nentropy(T) = 47.5 * 4 * T^3 * pi^2 / 90 * fmGeV^3\nentropyToTemp = InverseFunction(entropy)\ndSdT(T) = 1 / (3 * 47.5 * 4 * T^2 * pi^2 / 90 * fmGeV^2)\n\nbg, twopt = generate_bg_two_pt_fct(\n    entropyToTemp,\n    dSdT,\n    1.0,\n    Lead(),\n    Lead(),\n    0.5,\n    1.0,\n    0.0,\n    2760,\n    [10, 20],\n    [2];\n    minBiasEvents = 10_000,\n    r_grid = 0:1:10,\n    nFields = 10,\n)","category":"section"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"background/#Model-Parameters","page":"Background","title":"Model Parameters","text":"The Glauber model here exposes the following common parameters:\n\nw: Sub-nucleon width (fm). Controls the smearing of participant thickness.\nk: Fluctuation (shape) parameter for Gamma-distributed participant weights.\np: Reduced thickness parameter in the generalized mean.\ns_NN: Center-of-mass energy in GeV; used to compute the inelastic cross section.","category":"section"},{"location":"background/#Impact-Parameter","page":"Background","title":"Impact Parameter","text":"When you call Participants(n1, n2, w, s_NN, k, p) without an explicit impact parameter range, the code generates minimum-bias events with an internal default range. To restrict the impact parameter distribution, pass a tuple (bmin, bmax) as the last positional argument:\n\nparticipants = Participants(n1, n2, w, s_NN, k, p, (1.0, 2.0))","category":"section"},{"location":"background/#Nucleus-Choices","page":"Background","title":"Nucleus Choices","text":"Use one of the built-in nucleus helpers:\n\nLead(), Gold(), Uranium(), Copper(), Xenon() for Woods-Saxon nuclei.\nOxigen() and Neon() for tabulated light-ion configurations.","category":"section"},{"location":"background/#Event-Profiles","page":"Background","title":"Event Profiles","text":"Participant objects are callable: evt(x, y) returns the fluctuating thickness at coordinates (x, y). This enables direct integration for eccentricities or sampling on grids for visualization.","category":"section"},{"location":"#MonteCarloGlauber.jl","page":"Home","title":"MonteCarloGlauber.jl","text":"MonteCarloGlauber.jl generates initial conditions for heavy-ion collisions using a Monte Carlo Glauber model with sub-nucleonic fluctuations. It provides 3D Woods-Saxon sampling, participant and binary-collision counting, and utilities for centrality selection and two-point correlators.","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Deformed 3D Woods-Saxon nuclei (NucleiWoodSaxon3D).\nIntegrated Woods-Saxon sampling with interpolation (IntegratedWoodSaxon, IntegratedWoodSaxonInterp).\nEvent-by-event participants and multiplicities (Participants, Participant).\nLight-ion configurations via artifacts (Oxigen, Neon).\nBackground and two-point correlator helpers (generate_bg_two_pt_fct, generate_bg_twpt_fct).","category":"section"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"using MonteCarloGlauber\n\nn1 = Lead()\nn2 = Lead()\n\nw = 0.5\ns_NN = 2760\nk = 1\np = 0.0\n\nparticipants = Participants(n1, n2, w, s_NN, k, p)\nevents = rand(participants, 1000)\n\nmult = multiplicity.(events)\nb = impactParameter.(events)\n\nSee the Quickstart and Examples pages for more complete workflows.","category":"section"}]
}
